#pragma once

#include <concepts>
#include <memory>

#include <llvm/IR/Value.h>
#include <llvm/IR/Type.h>

#include "types.hpp"

namespace ast {

    class value_visitor;
    class type_visitor;

    /**
     * Expression class that all AST node must be inherited from.
     * @brief AST expression base class
     */
    class expression {
    private:
	types::type* _type{}; ///< Type of expression, set by semantic analyzer

    public:
	virtual ~expression() = default;

	/**
	 * Type accesor for non-const expression
	 * @return reference to the type of the expression
	 */
	[[nodiscard]] auto type()       -> types::type*&;

	/**
	 * Type accesor for const expression
	 * @return const reference to the type of the expression
	 */
	[[nodiscard]] auto type() const -> types::type* const &;

	/**
	 * Accept value visitor (usually a code generator), should not be called unless type is set
	 * @param v a visitor to accept
	 * @return llvm::Value that was generated by visitor
	 */
	[[nodiscard]] virtual auto accept(value_visitor* v) const -> llvm::Value* = 0;

	/**
	 * Accept type visitor (usually a semantic analyzer)
	 * Generates type of expression based on expression
	 * @param v a visitor to accept
	 * @return llvm::Value that was generated by visitor
	 */
	[[nodiscard]] virtual auto accept(type_visitor* v) -> types::type* = 0;
    };

}
